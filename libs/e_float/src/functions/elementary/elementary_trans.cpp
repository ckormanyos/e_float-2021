
//          Copyright Christopher Kormanyos 1999 - 2021.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

// This work is based on an earlier work:
// "Algorithm 910: A Portable C++ Multiple-Precision System for Special-Function Calculations",
// in ACM TOMS, {VOL 37, ISSUE 4, (February 2011)} (C) ACM, 2011. http://doi.acm.org/10.1145/1916461.1916469

#include <array>
#include <map>
#include <numeric>
#include <vector>

#include <e_float/e_float_functions.h>
#include <e_float/detail/e_float_detail_pown_template.h>

#include <utility/util_lexical_cast.h>
#include <utility/util_power_x_pow_n.h>

namespace ElementaryTrans_Series
{
  static e_float rootn_inv(const e_float& x, const std::int32_t p);
}

e_float ef::pow2(const std::int64_t p)
{
  // Create a static const table of p^2 for -128 < p < +128.
  // Note: The size of this table must be odd-numbered and
  // symmetric about 0.
  static const std::array<e_float, 255U> p2_data =
  {{
    e_float("5.877471754111437539843682686111228389093327783860437607543758531392086297273635864257812500000000000e-39"),
    e_float("1.175494350822287507968736537222245677818665556772087521508751706278417259454727172851562500000000000e-38"),
    e_float("2.350988701644575015937473074444491355637331113544175043017503412556834518909454345703125000000000000e-38"),
    e_float("4.701977403289150031874946148888982711274662227088350086035006825113669037818908691406250000000000000e-38"),
    e_float("9.403954806578300063749892297777965422549324454176700172070013650227338075637817382812500000000000000e-38"),
    e_float("1.880790961315660012749978459555593084509864890835340034414002730045467615127563476562500000000000000e-37"),
    e_float("3.761581922631320025499956919111186169019729781670680068828005460090935230255126953125000000000000000e-37"),
    e_float("7.523163845262640050999913838222372338039459563341360137656010920181870460510253906250000000000000000e-37"),
    e_float("1.504632769052528010199982767644474467607891912668272027531202184036374092102050781250000000000000000e-36"),
    e_float("3.009265538105056020399965535288948935215783825336544055062404368072748184204101562500000000000000000e-36"),
    e_float("6.018531076210112040799931070577897870431567650673088110124808736145496368408203125000000000000000000e-36"),
    e_float("1.203706215242022408159986214115579574086313530134617622024961747229099273681640625000000000000000000e-35"),
    e_float("2.407412430484044816319972428231159148172627060269235244049923494458198547363281250000000000000000000e-35"),
    e_float("4.814824860968089632639944856462318296345254120538470488099846988916397094726562500000000000000000000e-35"),
    e_float("9.629649721936179265279889712924636592690508241076940976199693977832794189453125000000000000000000000e-35"),
    e_float("1.925929944387235853055977942584927318538101648215388195239938795566558837890625000000000000000000000e-34"),
    e_float("3.851859888774471706111955885169854637076203296430776390479877591133117675781250000000000000000000000e-34"),
    e_float("7.703719777548943412223911770339709274152406592861552780959755182266235351562500000000000000000000000e-34"),
    e_float("1.540743955509788682444782354067941854830481318572310556191951036453247070312500000000000000000000000e-33"),
    e_float("3.081487911019577364889564708135883709660962637144621112383902072906494140625000000000000000000000000e-33"),
    e_float("6.162975822039154729779129416271767419321925274289242224767804145812988281250000000000000000000000000e-33"),
    e_float("1.232595164407830945955825883254353483864385054857848444953560829162597656250000000000000000000000000e-32"),
    e_float("2.465190328815661891911651766508706967728770109715696889907121658325195312500000000000000000000000000e-32"),
    e_float("4.930380657631323783823303533017413935457540219431393779814243316650390625000000000000000000000000000e-32"),
    e_float("9.860761315262647567646607066034827870915080438862787559628486633300781250000000000000000000000000000e-32"),
    e_float("1.972152263052529513529321413206965574183016087772557511925697326660156250000000000000000000000000000e-31"),
    e_float("3.944304526105059027058642826413931148366032175545115023851394653320312500000000000000000000000000000e-31"),
    e_float("7.888609052210118054117285652827862296732064351090230047702789306640625000000000000000000000000000000e-31"),
    e_float("1.577721810442023610823457130565572459346412870218046009540557861328125000000000000000000000000000000e-30"),
    e_float("3.155443620884047221646914261131144918692825740436092019081115722656250000000000000000000000000000000e-30"),
    e_float("6.310887241768094443293828522262289837385651480872184038162231445312500000000000000000000000000000000e-30"),
    e_float("1.262177448353618888658765704452457967477130296174436807632446289062500000000000000000000000000000000e-29"),
    e_float("2.524354896707237777317531408904915934954260592348873615264892578125000000000000000000000000000000000e-29"),
    e_float("5.048709793414475554635062817809831869908521184697747230529785156250000000000000000000000000000000000e-29"),
    e_float("1.009741958682895110927012563561966373981704236939549446105957031250000000000000000000000000000000000e-28"),
    e_float("2.019483917365790221854025127123932747963408473879098892211914062500000000000000000000000000000000000e-28"),
    e_float("4.038967834731580443708050254247865495926816947758197784423828125000000000000000000000000000000000000e-28"),
    e_float("8.077935669463160887416100508495730991853633895516395568847656250000000000000000000000000000000000000e-28"),
    e_float("1.615587133892632177483220101699146198370726779103279113769531250000000000000000000000000000000000000e-27"),
    e_float("3.231174267785264354966440203398292396741453558206558227539062500000000000000000000000000000000000000e-27"),
    e_float("6.462348535570528709932880406796584793482907116413116455078125000000000000000000000000000000000000000e-27"),
    e_float("1.292469707114105741986576081359316958696581423282623291015625000000000000000000000000000000000000000e-26"),
    e_float("2.584939414228211483973152162718633917393162846565246582031250000000000000000000000000000000000000000e-26"),
    e_float("5.169878828456422967946304325437267834786325693130493164062500000000000000000000000000000000000000000e-26"),
    e_float("1.033975765691284593589260865087453566957265138626098632812500000000000000000000000000000000000000000e-25"),
    e_float("2.067951531382569187178521730174907133914530277252197265625000000000000000000000000000000000000000000e-25"),
    e_float("4.135903062765138374357043460349814267829060554504394531250000000000000000000000000000000000000000000e-25"),
    e_float("8.271806125530276748714086920699628535658121109008789062500000000000000000000000000000000000000000000e-25"),
    e_float("1.654361225106055349742817384139925707131624221801757812500000000000000000000000000000000000000000000e-24"),
    e_float("3.308722450212110699485634768279851414263248443603515625000000000000000000000000000000000000000000000e-24"),
    e_float("6.617444900424221398971269536559702828526496887207031250000000000000000000000000000000000000000000000e-24"),
    e_float("1.323488980084844279794253907311940565705299377441406250000000000000000000000000000000000000000000000e-23"),
    e_float("2.646977960169688559588507814623881131410598754882812500000000000000000000000000000000000000000000000e-23"),
    e_float("5.293955920339377119177015629247762262821197509765625000000000000000000000000000000000000000000000000e-23"),
    e_float("1.058791184067875423835403125849552452564239501953125000000000000000000000000000000000000000000000000e-22"),
    e_float("2.117582368135750847670806251699104905128479003906250000000000000000000000000000000000000000000000000e-22"),
    e_float("4.235164736271501695341612503398209810256958007812500000000000000000000000000000000000000000000000000e-22"),
    e_float("8.470329472543003390683225006796419620513916015625000000000000000000000000000000000000000000000000000e-22"),
    e_float("1.694065894508600678136645001359283924102783203125000000000000000000000000000000000000000000000000000e-21"),
    e_float("3.388131789017201356273290002718567848205566406250000000000000000000000000000000000000000000000000000e-21"),
    e_float("6.776263578034402712546580005437135696411132812500000000000000000000000000000000000000000000000000000e-21"),
    e_float("1.355252715606880542509316001087427139282226562500000000000000000000000000000000000000000000000000000e-20"),
    e_float("2.710505431213761085018632002174854278564453125000000000000000000000000000000000000000000000000000000e-20"),
    e_float("5.421010862427522170037264004349708557128906250000000000000000000000000000000000000000000000000000000e-20"),
    e_float("1.084202172485504434007452800869941711425781250000000000000000000000000000000000000000000000000000000e-19"),
    e_float("2.168404344971008868014905601739883422851562500000000000000000000000000000000000000000000000000000000e-19"),
    e_float("4.336808689942017736029811203479766845703125000000000000000000000000000000000000000000000000000000000e-19"),
    e_float("8.673617379884035472059622406959533691406250000000000000000000000000000000000000000000000000000000000e-19"),
    e_float("1.734723475976807094411924481391906738281250000000000000000000000000000000000000000000000000000000000e-18"),
    e_float("3.469446951953614188823848962783813476562500000000000000000000000000000000000000000000000000000000000e-18"),
    e_float("6.938893903907228377647697925567626953125000000000000000000000000000000000000000000000000000000000000e-18"),
    e_float("1.387778780781445675529539585113525390625000000000000000000000000000000000000000000000000000000000000e-17"),
    e_float("2.775557561562891351059079170227050781250000000000000000000000000000000000000000000000000000000000000e-17"),
    e_float("5.551115123125782702118158340454101562500000000000000000000000000000000000000000000000000000000000000e-17"),
    e_float("1.110223024625156540423631668090820312500000000000000000000000000000000000000000000000000000000000000e-16"),
    e_float("2.220446049250313080847263336181640625000000000000000000000000000000000000000000000000000000000000000e-16"),
    e_float("4.440892098500626161694526672363281250000000000000000000000000000000000000000000000000000000000000000e-16"),
    e_float("8.881784197001252323389053344726562500000000000000000000000000000000000000000000000000000000000000000e-16"),
    e_float("1.776356839400250464677810668945312500000000000000000000000000000000000000000000000000000000000000000e-15"),
    e_float("3.552713678800500929355621337890625000000000000000000000000000000000000000000000000000000000000000000e-15"),
    e_float("7.105427357601001858711242675781250000000000000000000000000000000000000000000000000000000000000000000e-15"),
    e_float("1.421085471520200371742248535156250000000000000000000000000000000000000000000000000000000000000000000e-14"),
    e_float("2.842170943040400743484497070312500000000000000000000000000000000000000000000000000000000000000000000e-14"),
    e_float("5.684341886080801486968994140625000000000000000000000000000000000000000000000000000000000000000000000e-14"),
    e_float("1.136868377216160297393798828125000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    e_float("2.273736754432320594787597656250000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    e_float("4.547473508864641189575195312500000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    e_float("9.094947017729282379150390625000000000000000000000000000000000000000000000000000000000000000000000000e-13"),
    e_float("1.818989403545856475830078125000000000000000000000000000000000000000000000000000000000000000000000000e-12"),
    e_float("3.637978807091712951660156250000000000000000000000000000000000000000000000000000000000000000000000000e-12"),
    e_float("7.275957614183425903320312500000000000000000000000000000000000000000000000000000000000000000000000000e-12"),
    e_float("1.455191522836685180664062500000000000000000000000000000000000000000000000000000000000000000000000000e-11"),
    e_float("2.910383045673370361328125000000000000000000000000000000000000000000000000000000000000000000000000000e-11"),
    e_float("5.820766091346740722656250000000000000000000000000000000000000000000000000000000000000000000000000000e-11"),
    e_float("1.164153218269348144531250000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    e_float("2.328306436538696289062500000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    e_float("4.656612873077392578125000000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    e_float("9.313225746154785156250000000000000000000000000000000000000000000000000000000000000000000000000000000e-10"),
    e_float("1.862645149230957031250000000000000000000000000000000000000000000000000000000000000000000000000000000e-9"),
    e_float("3.725290298461914062500000000000000000000000000000000000000000000000000000000000000000000000000000000e-9"),
    e_float("7.450580596923828125000000000000000000000000000000000000000000000000000000000000000000000000000000000e-9"),
    e_float("1.490116119384765625000000000000000000000000000000000000000000000000000000000000000000000000000000000e-8"),
    e_float("2.980232238769531250000000000000000000000000000000000000000000000000000000000000000000000000000000000e-8"),
    e_float("5.960464477539062500000000000000000000000000000000000000000000000000000000000000000000000000000000000e-8"),
    e_float("1.192092895507812500000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    e_float("2.384185791015625000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    e_float("4.768371582031250000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    e_float("9.536743164062500000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-7"),
    e_float("1.907348632812500000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-6"),
    e_float("3.814697265625000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-6"),
    e_float("7.629394531250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-6"),
    e_float("0.000015258789062500000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.000030517578125000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.000061035156250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.000122070312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.000244140625000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.000488281250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.000976562500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.001953125000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.003906250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.007812500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.01562500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.03125000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    e_float("0.06250000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
    ef::eighth(),
    ef::quarter(),
    ef::half(),
    ef::one(),
    ef::two(),
    ef::four(),
    ef::eight(),
    e_float(16),
    e_float(32),
    e_float(64),
    e_float(128),
    e_float(256),
    e_float(512),
    e_float(1024),
    e_float(2048),
    e_float(4096),
    e_float(8192),
    e_float(16384),
    e_float(32768),
    e_float(65536),
    e_float(131072),
    e_float(262144),
    e_float(524288),
    e_float(static_cast<std::uint32_t>(1UL << 20U)),
    e_float(static_cast<std::uint32_t>(1UL << 21U)),
    e_float(static_cast<std::uint32_t>(1UL << 22U)),
    e_float(static_cast<std::uint32_t>(1UL << 23U)),
    e_float(static_cast<std::uint32_t>(1UL << 24U)),
    e_float(static_cast<std::uint32_t>(1UL << 25U)),
    e_float(static_cast<std::uint32_t>(1UL << 26U)),
    e_float(static_cast<std::uint32_t>(1UL << 27U)),
    e_float(static_cast<std::uint32_t>(1UL << 28U)),
    e_float(static_cast<std::uint32_t>(1UL << 29U)),
    e_float(static_cast<std::uint32_t>(1UL << 30U)),
    e_float(static_cast<std::uint32_t>(1UL << 31U)),
    e_float(static_cast<std::uint64_t>(1ULL << 32U)),
    e_float(static_cast<std::uint64_t>(1ULL << 33U)),
    e_float(static_cast<std::uint64_t>(1ULL << 34U)),
    e_float(static_cast<std::uint64_t>(1ULL << 35U)),
    e_float(static_cast<std::uint64_t>(1ULL << 36U)),
    e_float(static_cast<std::uint64_t>(1ULL << 37U)),
    e_float(static_cast<std::uint64_t>(1ULL << 38U)),
    e_float(static_cast<std::uint64_t>(1ULL << 39U)),
    e_float(static_cast<std::uint64_t>(1ULL << 40U)),
    e_float(static_cast<std::uint64_t>(1ULL << 41U)),
    e_float(static_cast<std::uint64_t>(1ULL << 42U)),
    e_float(static_cast<std::uint64_t>(1ULL << 43U)),
    e_float(static_cast<std::uint64_t>(1ULL << 44U)),
    e_float(static_cast<std::uint64_t>(1ULL << 45U)),
    e_float(static_cast<std::uint64_t>(1ULL << 46U)),
    e_float(static_cast<std::uint64_t>(1ULL << 47U)),
    e_float(static_cast<std::uint64_t>(1ULL << 48U)),
    e_float(static_cast<std::uint64_t>(1ULL << 49U)),
    e_float(static_cast<std::uint64_t>(1ULL << 50U)),
    e_float(static_cast<std::uint64_t>(1ULL << 51U)),
    e_float(static_cast<std::uint64_t>(1ULL << 52U)),
    e_float(static_cast<std::uint64_t>(1ULL << 53U)),
    e_float(static_cast<std::uint64_t>(1ULL << 54U)),
    e_float(static_cast<std::uint64_t>(1ULL << 55U)),
    e_float(static_cast<std::uint64_t>(1ULL << 56U)),
    e_float(static_cast<std::uint64_t>(1ULL << 57U)),
    e_float(static_cast<std::uint64_t>(1ULL << 58U)),
    e_float(static_cast<std::uint64_t>(1ULL << 59U)),
    e_float(static_cast<std::uint64_t>(1ULL << 60U)),
    e_float(static_cast<std::uint64_t>(1ULL << 61U)),
    e_float(static_cast<std::uint64_t>(1ULL << 62U)),
    e_float(static_cast<std::uint64_t>(1ULL << 63U)),
    e_float("1.844674407370955161600000000000000000000000000000000000000000000000000000000000000000000000000000000e19"),
    e_float("3.689348814741910323200000000000000000000000000000000000000000000000000000000000000000000000000000000e19"),
    e_float("7.378697629483820646400000000000000000000000000000000000000000000000000000000000000000000000000000000e19"),
    e_float("1.475739525896764129280000000000000000000000000000000000000000000000000000000000000000000000000000000e20"),
    e_float("2.951479051793528258560000000000000000000000000000000000000000000000000000000000000000000000000000000e20"),
    e_float("5.902958103587056517120000000000000000000000000000000000000000000000000000000000000000000000000000000e20"),
    e_float("1.180591620717411303424000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    e_float("2.361183241434822606848000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    e_float("4.722366482869645213696000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    e_float("9.444732965739290427392000000000000000000000000000000000000000000000000000000000000000000000000000000e21"),
    e_float("1.888946593147858085478400000000000000000000000000000000000000000000000000000000000000000000000000000e22"),
    e_float("3.777893186295716170956800000000000000000000000000000000000000000000000000000000000000000000000000000e22"),
    e_float("7.555786372591432341913600000000000000000000000000000000000000000000000000000000000000000000000000000e22"),
    e_float("1.511157274518286468382720000000000000000000000000000000000000000000000000000000000000000000000000000e23"),
    e_float("3.022314549036572936765440000000000000000000000000000000000000000000000000000000000000000000000000000e23"),
    e_float("6.044629098073145873530880000000000000000000000000000000000000000000000000000000000000000000000000000e23"),
    e_float("1.208925819614629174706176000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    e_float("2.417851639229258349412352000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    e_float("4.835703278458516698824704000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    e_float("9.671406556917033397649408000000000000000000000000000000000000000000000000000000000000000000000000000e24"),
    e_float("1.934281311383406679529881600000000000000000000000000000000000000000000000000000000000000000000000000e25"),
    e_float("3.868562622766813359059763200000000000000000000000000000000000000000000000000000000000000000000000000e25"),
    e_float("7.737125245533626718119526400000000000000000000000000000000000000000000000000000000000000000000000000e25"),
    e_float("1.547425049106725343623905280000000000000000000000000000000000000000000000000000000000000000000000000e26"),
    e_float("3.094850098213450687247810560000000000000000000000000000000000000000000000000000000000000000000000000e26"),
    e_float("6.189700196426901374495621120000000000000000000000000000000000000000000000000000000000000000000000000e26"),
    e_float("1.237940039285380274899124224000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    e_float("2.475880078570760549798248448000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    e_float("4.951760157141521099596496896000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    e_float("9.903520314283042199192993792000000000000000000000000000000000000000000000000000000000000000000000000e27"),
    e_float("1.980704062856608439838598758400000000000000000000000000000000000000000000000000000000000000000000000e28"),
    e_float("3.961408125713216879677197516800000000000000000000000000000000000000000000000000000000000000000000000e28"),
    e_float("7.922816251426433759354395033600000000000000000000000000000000000000000000000000000000000000000000000e28"),
    e_float("1.584563250285286751870879006720000000000000000000000000000000000000000000000000000000000000000000000e29"),
    e_float("3.169126500570573503741758013440000000000000000000000000000000000000000000000000000000000000000000000e29"),
    e_float("6.338253001141147007483516026880000000000000000000000000000000000000000000000000000000000000000000000e29"),
    e_float("1.267650600228229401496703205376000000000000000000000000000000000000000000000000000000000000000000000e30"),
    e_float("2.535301200456458802993406410752000000000000000000000000000000000000000000000000000000000000000000000e30"),
    e_float("5.070602400912917605986812821504000000000000000000000000000000000000000000000000000000000000000000000e30"),
    e_float("1.014120480182583521197362564300800000000000000000000000000000000000000000000000000000000000000000000e31"),
    e_float("2.028240960365167042394725128601600000000000000000000000000000000000000000000000000000000000000000000e31"),
    e_float("4.056481920730334084789450257203200000000000000000000000000000000000000000000000000000000000000000000e31"),
    e_float("8.112963841460668169578900514406400000000000000000000000000000000000000000000000000000000000000000000e31"),
    e_float("1.622592768292133633915780102881280000000000000000000000000000000000000000000000000000000000000000000e32"),
    e_float("3.245185536584267267831560205762560000000000000000000000000000000000000000000000000000000000000000000e32"),
    e_float("6.490371073168534535663120411525120000000000000000000000000000000000000000000000000000000000000000000e32"),
    e_float("1.298074214633706907132624082305024000000000000000000000000000000000000000000000000000000000000000000e33"),
    e_float("2.596148429267413814265248164610048000000000000000000000000000000000000000000000000000000000000000000e33"),
    e_float("5.192296858534827628530496329220096000000000000000000000000000000000000000000000000000000000000000000e33"),
    e_float("1.038459371706965525706099265844019200000000000000000000000000000000000000000000000000000000000000000e34"),
    e_float("2.076918743413931051412198531688038400000000000000000000000000000000000000000000000000000000000000000e34"),
    e_float("4.153837486827862102824397063376076800000000000000000000000000000000000000000000000000000000000000000e34"),
    e_float("8.307674973655724205648794126752153600000000000000000000000000000000000000000000000000000000000000000e34"),
    e_float("1.661534994731144841129758825350430720000000000000000000000000000000000000000000000000000000000000000e35"),
    e_float("3.323069989462289682259517650700861440000000000000000000000000000000000000000000000000000000000000000e35"),
    e_float("6.646139978924579364519035301401722880000000000000000000000000000000000000000000000000000000000000000e35"),
    e_float("1.329227995784915872903807060280344576000000000000000000000000000000000000000000000000000000000000000e36"),
    e_float("2.658455991569831745807614120560689152000000000000000000000000000000000000000000000000000000000000000e36"),
    e_float("5.316911983139663491615228241121378304000000000000000000000000000000000000000000000000000000000000000e36"),
    e_float("1.063382396627932698323045648224275660800000000000000000000000000000000000000000000000000000000000000e37"),
    e_float("2.126764793255865396646091296448551321600000000000000000000000000000000000000000000000000000000000000e37"),
    e_float("4.253529586511730793292182592897102643200000000000000000000000000000000000000000000000000000000000000e37"),
    e_float("8.507059173023461586584365185794205286400000000000000000000000000000000000000000000000000000000000000e37"),
    e_float("1.701411834604692317316873037158841057280000000000000000000000000000000000000000000000000000000000000e38")
  }};

  if((p > static_cast<std::int64_t>(-128)) && (p < static_cast<std::int64_t>(+128)))
  {
    return p2_data[static_cast<std::size_t>(p + static_cast<std::int64_t>((p2_data.size() - 1U) / 2U))];
  }

  // Compute and return 2^p.
  if(p < static_cast<std::int64_t>(0))
  {
    return ef::pow2(static_cast<std::int64_t>(-p)).calculate_inv();
  }
  else if(p < static_cast<std::int64_t>(std::numeric_limits<std::uint64_t>::digits))
  {
    const std::uint64_t p2 = static_cast<std::uint64_t>(static_cast<std::uint64_t>(1ULL) << p);
    return e_float(p2);
  }
  else
  {
    return Util::x_pow_n_template(ef::two(), p);
  }
}

static e_float ElementaryTrans_Series::rootn_inv(const e_float& x, const std::int32_t p)
{
  // Compute the value of [1 / (rootn of x)] with n = p.

  // Generate the initial estimate using 1 / rootn.
  // Extract the mantissa and exponent for a "manual"
  // computation of the estimate.
  double        dd;
  std::int64_t  ne;

  ef::to_parts(x, dd, ne);

  // Adjust exponent and mantissa such that ne is an even power of p.
  while(ne % static_cast<std::int64_t>(p))
  {
    ++ne;
    dd /= 10.0;
  }
  
  // Estimate the one over the root using simple manipulations.
  const double one_over_rtn_d = ::pow(dd, -1.0 / static_cast<double>(p));

  // Set the result equal to the initial guess.
  e_float result(one_over_rtn_d, static_cast<std::int64_t>(-ne / p));

  static const std::int32_t double_digits10_minus_a_few = static_cast<std::int32_t>(static_cast<std::int32_t>(std::numeric_limits<double>::digits10) - static_cast<std::int32_t>(3));

  for(std::int32_t digits = double_digits10_minus_a_few; digits <= static_cast<std::int32_t>(ef::tolerance()); digits *= static_cast<std::int32_t>(2))
  {
    // Adjust precision of the terms.
    const std::int32_t new_prec = static_cast<std::int32_t>(digits * 2) + 10;

    result.precision(new_prec);

    // Perform the next iteration.
    e_float term = (((-ef::detail::pown_template(result, p) * x) + ef::one()) / p) + ef::one();

    term.precision(new_prec);

    result *= term;
  
  }

  result.precision(static_cast<std::int32_t>(ef::tolerance()));

  return result;
}

e_float ef::inv (const e_float& x) { return e_float(x).calculate_inv(); }
e_float ef::sqrt(const e_float& x) { return e_float(x).calculate_sqrt(); }

e_float ef::cbrt(const e_float& x)
{
  return ef::rootn(x, static_cast<std::int32_t>(3));
}

e_float ef::rootn(const e_float& x, const std::int32_t p)
{
  if(!ef::isfinite(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(p < static_cast<std::int32_t>(0))
  {
    return ef::rootn(ef::one() / x, static_cast<std::int32_t>(-p));
  }

  if((p == static_cast<std::int32_t>(0)) || ef::isneg(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }
  else if(p == static_cast<std::int32_t>(1))
  {
    return x;
  }
  else if(p == static_cast<std::int32_t>(2))
  {
    return ef::sqrt(x);
  }
  else if((p == static_cast<std::int32_t>(3)) && x.i_have_my_own_cbrt())
  {
    return e_float::my_own_cbrt(x);
  }

  const e_float rtn =  (x.i_have_my_own_rootn() ? e_float::my_own_rootn(x, static_cast<std::uint32_t>(p))
                                                : ElementaryTrans_Series::rootn_inv(x, p).calculate_inv());

  return rtn;
}

e_float ef::rootn_inverse(const e_float& x, const std::int32_t p)
{
  if(!ef::isfinite(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(p < static_cast<std::int32_t>(0))
  {
    return detail::pown_template(x, static_cast<std::int32_t>(-p));
  }

  if((p == static_cast<std::int32_t>(0)) || ef::isneg(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }
  else if(p == static_cast<std::int32_t>(1))
  {
    return x;
  }
  else if(p == static_cast<std::int32_t>(2))
  {
    return ef::one() / ef::sqrt(x);
  }

  const e_float rtn_inv =  (x.i_have_my_own_rootn() ? ef::one() / e_float::my_own_rootn(x, static_cast<std::uint32_t>(p))
                                                    : ElementaryTrans_Series::rootn_inv(x, p));

  return rtn_inv;
}

e_float ef::exp(const e_float& x)
{
  if(x.i_have_my_own_exp())
  {
    return e_float::my_own_exp(x);
  }

  // Handle special arguments.
  if(ef::isnan(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(ef::isinf(x))
  {
    return ((!ef::isneg(x)) ? std::numeric_limits<e_float>::infinity() : ef::zero());
  }

  if(ef::iszero(x) || (x.order() < -ef::tolerance()))
  {
    return ef::one();
  }

  // Get local copy of argument and force it to be positive.
  const bool bo_x_is_neg = ef::isneg(x);

  const e_float xx = ((!bo_x_is_neg) ? x : -x);

  // Check the range of the argument.
  static const e_float maximum_arg_for_exp = std::numeric_limits<e_float>::max_exponent;

  if(xx > maximum_arg_for_exp)
  {
    // Overflow / underflow
    return ((!bo_x_is_neg) ? std::numeric_limits<e_float>::infinity() : ef::zero());
  }

  // Check for pure-integer arguments which can be either signed or unsigned.
  if(ef::isint(x))
  {
    return ef::detail::pown_template(ef::e(), ef::to_int64(x));
  }

  // The algorithm for exp has been taken from MPFUN.
  // exp(t) = [ (1 + r + r^2/2! + r^3/3! + r^4/4! ...)^p2 ] * 2^n
  // where p2 is a power of 2 such as 2048, r = t_prime / p2, and
  // t_prime = t - n*ln2, with n chosen to minimize the absolute
  // value of t_prime. In the resulting Taylor series, which is
  // implemented as a hypergeometric function, |r| is bounded by
  // ln2 / p2. For small arguments, no scaling is done.

  const bool b_scale = (xx.order() > static_cast<std::int64_t>(-4));

  // Compute the exponential series of the (possibly) scaled argument.
  e_float exp_series;

  if(b_scale)
  {
    // Compute 1 / ln2 as a warm-cached constant value.
    static const e_float one_over_ln2 = ef::one() / ef::ln2();

    const e_float nf = ef::integer_part(xx * one_over_ln2);

    // The scaling is 2^11 = 2048.
    const std::int32_t p2 = static_cast<std::int32_t>(std::uint32_t(1U) << 11);

    exp_series = ef::detail::pown_template(ef::hypergeometric_0f0((xx - (nf * ef::ln2())) / p2), static_cast<std::int64_t>(p2)) * ef::pow2(ef::to_int64(nf));
  }
  else
  {
    exp_series = ef::hypergeometric_0f0(xx);
  }

  return ((!bo_x_is_neg) ? exp_series : (ef::one() / exp_series));
}

namespace Log_Series
{
  static e_float AtOne(const e_float& x)
  {
    // This subroutine computes the series representation of Log[1 + x]
    // for small x without losing precision.

    // http://functions.wolfram.com/ElementaryFunctions/Log/26/01/01/

    return x * ef::hypergeometric_2f1( ef::one(), ef::one(), ef::two(), -x);
  }
}

e_float ef::log(const e_float& x)
{
  // Handle special arguments.
  if(ef::isnan(x) || ef::isneg(x) || ef::isinf(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(x.i_have_my_own_log())
  {
    return e_float::my_own_log(x);
  }

  if(ef::iszero(x))
  {
    return -std::numeric_limits<e_float>::infinity();
  }

  if(ef::isone(x))
  {
    return ef::zero();
  }

  // Make a local copy
  e_float xx = x;

  // Compute the delta of the argument compared to one.
  const e_float x_minus_one  = xx - ef::one();

  if(ef::near_one(xx))
  {
    return Log_Series::AtOne(x_minus_one);
  }

  // For large arguments, the value will be broken into two parts
  // in order to facilitate the convergence of the Newton iteration.
  const bool b_correction = (   (xx.order() > static_cast<std::int64_t>(+1000))
                             || (xx.order() < static_cast<std::int64_t>(-1000)));

  e_float correction;

  if(b_correction)
  {
    // The argument xx is of the form a * 10^b.
    // It will be broken into two parts: log(a) + b * log(10).
    const bool b_neg_exp = xx.order() < static_cast<std::int64_t>(0);

    // Remove a large power of ten from the argument. But be sure to leave the argument
    // large enough (or small enough) to avoid entering the near-one range.
    const std::int64_t n_order   = xx.order();
    const std::int64_t n_exp     = !b_neg_exp ? n_order : -n_order;
    const std::int64_t delta_exp = static_cast<std::int64_t>(n_exp - static_cast<std::int64_t>(8));

    // Convert the scaling power of ten to a string and subsequently to an e_float.
    const e_float ef_delta_exp("1E" + Util::lexical_cast(delta_exp));

    !b_neg_exp ? xx /= ef_delta_exp : xx *= ef_delta_exp;

    correction  = ef::ln10() * e_float(delta_exp);

    if(b_neg_exp)
    {
      correction = -correction;
    }
  }

  // Generate the initial estimate using double precision log combined with
  // the exponent for a "manual" computation of the initial iteration estimate.

  static const double lg10_d = ::log(10.0);

  static const std::int64_t n32_min = static_cast<std::int64_t>((std::numeric_limits<std::int32_t>::min)());
  static const std::int64_t n32_max = static_cast<std::int64_t>((std::numeric_limits<std::int32_t>::max)());

  // computation of the estimate.
  double        dd;
  std::int64_t  ne;
  ef::to_parts(xx, dd, ne);

  const double nd = ((ne < static_cast<std::int64_t>(0)) ? static_cast<double>(static_cast<std::int32_t>((std::max)(ne, n32_min)))
                                                  : static_cast<double>(static_cast<std::int32_t>((std::min)(ne, n32_max))));

  const double dlog = ::log(dd) + (nd * lg10_d);

  const double d10  = ((!ef::iszero(dlog)) ? ::log10(::fabs(dlog)) + 0.5 : 0.0);

  const std::int64_t  p10  =  (ef::ispos(dlog)  ? static_cast<std::int64_t>(d10) : static_cast<std::int64_t>(-d10));

  e_float log_val   = ((!ef::iszero(dlog)) ? e_float(dlog / ::pow(10.0, static_cast<double>(static_cast<std::int32_t>(p10))), p10)
                      : x_minus_one);

  // Newton-Raphson iteration
  static const std::int32_t double_digits10_minus_one = static_cast<std::int32_t>(static_cast<std::int32_t>(std::numeric_limits<double>::digits10) - static_cast<std::int32_t>(1));

  for(std::int32_t digits = double_digits10_minus_one; digits <= static_cast<std::int32_t>(ef::tolerance()); digits *= static_cast<std::int32_t>(2))
  {
    // Adjust precision of the terms.
    log_val.precision(static_cast<std::int32_t>(digits * static_cast<std::int32_t>(2)));
         xx.precision(static_cast<std::int32_t>(digits * static_cast<std::int32_t>(2)));

    const e_float exp_minus_log = ef::exp(-log_val);

    log_val += (xx * exp_minus_log) - ef::one();
  }

  return ((!b_correction) ? log_val : log_val + correction);
}

e_float ef::log10(const e_float& x)                   { return ef::log(x) / ef::ln10(); }
e_float ef::loga (const e_float& a, const e_float& x) { return ef::log(x) / ef::log(a); }
e_float ef::log1p(const e_float& x)                   { return Log_Series::AtOne(x); }

e_float ef::log1p1m2(const e_float& x)
{
  // This subroutine calculates the series representation of (1/2) Log[(1 + x) / (1 - x)]
  // for small x without losing precision.

  if(!ef::isfinite(x))
  {
    return x;
  }

  if((x <= ef::one_minus()) || (x >= ef::one()))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  // for values of x near one.
  const e_float x2 = x * x;
        e_float xn = x;

  e_float sum = xn;

  // Series representation of (1/2) Log[(1 + x) / (1 - x)] as given in
  // Schaum's Outlines: Mathematical Handbook of Formulas and Tables,
  // Second Edition, equation 22.8, page 136.
  for(std::int32_t n = static_cast<std::int32_t>(3); n < ef::max_iteration(); n += static_cast<std::int32_t>(2))
  {
    xn *= x2;

    const e_float term = xn / n;

    if(n > static_cast<std::int32_t>(20))
    {
      const std::int64_t order_check = static_cast<std::int64_t>(term.order() - sum.order());

      if(order_check < -ef::tolerance())
      {
        break;
      }
    }

    sum += term;
  }

  return sum;
}

e_float ef::pow(const e_float& x, const e_float& a)
{
  if(!ef::isfinite(x) || ef::isone(a))
  {
    return x;
  }

  if(ef::iszero(x))
  {
    return ef::one();
  }
  
  if(ef::iszero(a))
  {
    return ef::one();
  }

  const bool bo_a_isint = ef::isint(a);

  if(ef::isneg(x) && !bo_a_isint)
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(a <= ef::one_minus())
  {
    return ef::one() / ef::pow(x, -a);
  }

  const e_float a_int = ef::integer_part(a);
  const std::int64_t   an    = ef::to_int64(a_int);
  const e_float da    = a - a_int;

  if(bo_a_isint)
  {
    return ef::detail::pown_template(x, an);
  }

  static const e_float nine_tenths = ef::nine() / static_cast<std::int32_t>(10);

  if(ef::ispos(x) && (x > ef::tenth()) && (x < nine_tenths))
  {
    if(ef::small_arg(a))
    {
      // Series expansion for small a.
      return ef::hypergeometric_0f0(a * ef::log(x));
    }
    else
    {
      // Series expansion for moderately sized x. Note that for large power of a,
      // the power of the integer part of a is calculated using the pown function.
      return ((an != static_cast<std::int64_t>(0)) ? ef::hypergeometric_1f0(-da, ef::one() - x) * ef::detail::pown_template(x, an)
                                                   : ef::hypergeometric_1f0( -a, ef::one() - x));
    }
  }
  else
  {
    // Series expansion for pow(x, a). Note that for large power of a, the power
    // of the integer part of a is calculated using the pown function.
    return ((an != static_cast<std::int64_t>(0)) ? ef::exp(da * ef::log(x)) * ef::detail::pown_template(x, an)
                                          : ef::exp( a * ef::log(x)));
  }
}

e_float ef::sinh(const e_float& x)
{
  if(x.i_have_my_own_sinh())
  {
    return e_float::my_own_sinh(x);
  }

  if(!ef::isfinite(x))
  {
    return x;
  }

  e_float s;
  ef::sinhcosh(x, &s, static_cast<e_float*>(0U));
  return s;
}

e_float ef::cosh(const e_float& x)
{
  if(x.i_have_my_own_cosh())
  {
    return e_float::my_own_cosh(x);
  }

  if(!ef::isfinite(x))
  {
    return x;
  }

  e_float c;
  ef::sinhcosh(x, static_cast<e_float*>(0U), &c);
  return c;
}

void ef::sinhcosh(const e_float& x, e_float* const p_sinh, e_float* const p_cosh)
{
  if(!ef::isfinite(x) || (!p_sinh && !p_cosh))
  {
    return;
  }
  
  if(ef::iszero(x))
  {
    if(p_sinh)
    {
      *p_sinh = ef::zero();
    }

    if(p_cosh)
    {
      *p_cosh = ef::one();
    }
    
    return;
  }

  const e_float e_px = ef::exp(x);
  const e_float e_mx = ef::one() / e_px;

  if(p_sinh != nullptr) { *p_sinh  = (e_px - e_mx) / static_cast<std::int32_t>(2); }
  if(p_cosh != nullptr) { *p_cosh  = (e_px + e_mx) / static_cast<std::int32_t>(2); }
}

e_float ef::tanh(const e_float& x)
{
  if(x.i_have_my_own_tanh())
  {
    return e_float::my_own_tanh(x);
  }

  e_float c, s;
  ef::sinhcosh(x, &s, &c);
  return s * c.calculate_inv();
}

e_float ef::asinh(const e_float& x)
{
  if(x.i_have_my_own_asinh())
  {
    return e_float::my_own_asinh(x);
  }

  if(!ef::isfinite(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(ef::iszero(x))
  {
    return ef::zero();
  }
  else
  {
    const e_float value = ef::log(ef::fabs(x) + ef::sqrt((x * x) + ef::one()));

    return !ef::isneg(x) ? value : -value;
  }
}

e_float ef::acosh(const e_float& x)
{
  if(x.i_have_my_own_acosh())
  {
    return e_float::my_own_acosh(x);
  }

  if(!ef::isfinite(x))
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(ef::isneg(x) || x < ef::one())
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  if(ef::isone(x))
  {
    return ef::one();
  }

  const e_float x_minus_one = x - ef::one();

  if(ef::small_arg(x_minus_one))
  {
    return   (ef::sqrt2() * ef::sqrt(x_minus_one))
           *  ef::hypergeometric_2f1( ef::half(),
                                      ef::half(),
                                      ef::three_half(),
                                     -x_minus_one / static_cast<std::int32_t>(2));
  }
  else
  {
    return ef::log(x + ef::sqrt((x * x) - ef::one()));
  }
}

e_float ef::atanh(const e_float& x)
{
  if(x.i_have_my_own_atanh())
  {
    return e_float::my_own_atanh(x);
  }

  if(!ef::isfinite(x))
  {
    return x;
  }

  const e_float xx = ef::fabs(x);
  
  if(xx >= ef::one())
  {
    return std::numeric_limits<e_float>::quiet_NaN();
  }

  const e_float value = (ef::small_arg(x) ?  ef::log1p1m2(x)
                                          : (ef::log((ef::one() + x) / (ef::one() - x)) / static_cast<std::int32_t>(2)));

  return ((!ef::isneg(xx)) ? value : -value);
}
